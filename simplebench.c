#include <stdio.h>#include <stdlib.h>#include <string.h>#include <linux/hw_breakpoint.h> /* Definition of HW_* constants */#include <linux/perf_event.h>    /* Definition of PERF_* constants */#include <sys/syscall.h>         /* Definition of SYS_* constants */#include <unistd.h>#include <sys/ioctl.h>#define SIZEOF_CACHE 8      // in MBs#define SIZEOF_CACHELINE 64 // in bytes#define MB (1024 * 1024)const int CONFIG_READ = PERF_COUNT_HW_CACHE_LL | PERF_COUNT_HW_CACHE_OP_READ << 8 | PERF_COUNT_HW_CACHE_RESULT_MISS << 16;const int CONFIG_WRITE = PERF_COUNT_HW_CACHE_LL | PERF_COUNT_HW_CACHE_OP_WRITE << 8 | PERF_COUNT_HW_CACHE_RESULT_MISS << 16;static long perf_event_open(struct perf_event_attr *hw_event, pid_t pid, int cpu, int group_fd, unsigned long flags) {    return syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);}int gen_perf_event_attr(struct perf_event_attr *attr, int config) {    memset(attr, 0, sizeof(struct perf_event_attr));    attr->type = PERF_TYPE_HW_CACHE;    attr->size = sizeof(struct perf_event_attr);    attr->config = config;    attr->exclude_kernel = 1;    attr->exclude_hv = 1;    attr->disabled = 1;    int fd = perf_event_open(attr, 0, -1, -1, 0);    if (fd == -1) {        fprintf(stderr, "Error opening leader %llx\n", attr->config);        exit(EXIT_FAILURE);    }    return fd;}// args should be the sizeof_cache in MBsint main(int argc, char *argv[]) {    unsigned long sizeof_cache = argc > 1 ? atoi(argv[1]) : SIZEOF_CACHE;    unsigned long array_size = sizeof_cache * MB / sizeof(unsigned long);    unsigned long *data = malloc(array_size * sizeof(unsigned long));    struct perf_event_attr pe_read;    int fd_read = gen_perf_event_attr(&pe_read, CONFIG_READ);    struct perf_event_attr pe_write;    int fd_write = gen_perf_event_attr(&pe_write, CONFIG_WRITE);    unsigned long fake = 0;    ioctl(fd_read, PERF_EVENT_IOC_RESET, 0);    ioctl(fd_write, PERF_EVENT_IOC_RESET, 0);    ioctl(fd_read, PERF_EVENT_IOC_ENABLE, 0);    ioctl(fd_write, PERF_EVENT_IOC_ENABLE, 0);    for (int i = 0; i < array_size; i++) {//        data[i] = i;        fake += data[i];    }    ioctl(fd_read, PERF_EVENT_IOC_DISABLE, 0);    ioctl(fd_write, PERF_EVENT_IOC_DISABLE, 0);    long long miss_count, miss_count_read, miss_count_write, miss_count_prefetch;    read(fd_read, &miss_count_read, sizeof(long long));    read(fd_write, &miss_count_write, sizeof(long long));    free(data);    printf("expected\t= %lu\n", array_size / SIZEOF_CACHELINE);    printf("miss_count\t= %lld\n", miss_count);    printf("miss_count_read\t= %lld\n", miss_count_read);    printf("miss_count_write\t= %lld\n", miss_count_write);    return 0;}