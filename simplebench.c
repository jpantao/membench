#include <stdio.h>#include <stdlib.h>#include <string.h>#include <linux/perf_event.h>    /* Definition of PERF_* constants */#include <sys/syscall.h>         /* Definition of SYS_* constants */#include <unistd.h>#include <sys/ioctl.h>#define SIZEOF_CACHE 8      // in MBs#define SIZEOF_CACHELINE 64 // in bytes#define MB (1024 * 1024)const int CONFIG_READ = PERF_COUNT_HW_CACHE_LL | PERF_COUNT_HW_CACHE_OP_READ << 8 | PERF_COUNT_HW_CACHE_RESULT_MISS << 16;static long perf_event_open(struct perf_event_attr *hw_event, pid_t pid, int cpu, int group_fd, unsigned long flags) {    return syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);}int gen_perf_event_attr(struct perf_event_attr *attr, int config) {    memset(attr, 0, sizeof(struct perf_event_attr));    attr->type = PERF_TYPE_HW_CACHE;    attr->size = sizeof(struct perf_event_attr);    attr->config = config;    attr->exclude_kernel = 1;    attr->exclude_hv = 1;    attr->disabled = 1;    int fd = perf_event_open(attr, 0, -1, -1, 0);    if (fd == -1) {        fprintf(stderr, "Error opening leader %llx\n", attr->config);        exit(EXIT_FAILURE);    }    return fd;}// args should be the sizeof_cache in MBsint main(int argc, char *argv[]) {    unsigned long sizeof_cache = argc > 1 ? atoi(argv[1]) : SIZEOF_CACHE;    unsigned long sizeof_data = sizeof_cache * MB ;    unsigned long data_len = sizeof_data / sizeof(unsigned long);    unsigned long *data = malloc(sizeof_data);    unsigned int seed = 0;    for (unsigned long i = 0; i < data_len; i++) {        data[i] = rand_r(&seed);    }    struct perf_event_attr pe_read;    int fd_read = gen_perf_event_attr(&pe_read, CONFIG_READ);    unsigned long fake = 0;    long long miss_count_read;    ioctl(fd_read, PERF_EVENT_IOC_RESET, 0);    for (int i = 0; i < data_len; i++) {        ioctl(fd_read, PERF_EVENT_IOC_ENABLE, 0);        fake += data[rand_r(&seed) % data_len];        ioctl(fd_read, PERF_EVENT_IOC_DISABLE, 0);        read(fd_read, &miss_count_read, sizeof(long long));        if (i % 1000 == 0) {            printf("iteration %d -> read miss count: %lld\n", i, miss_count_read);        }    }    free(data);    printf("expected misses\t= %lu\n", data_len / (SIZEOF_CACHELINE / sizeof (unsigned long)));    printf("miss_count_read\t= %lld\n", miss_count_read);    return 0;}